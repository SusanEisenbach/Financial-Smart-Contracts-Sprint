//! new-transaction
//! sender: alice
module ContractStore {
  import {{alice}}.One;

  resource T {
    contract: One.T,
  }

  public store(contract: One.T) {
    let contract_holder: Self.T;

    contract_holder = T {
      contract: move(contract),
    };

    move_to_sender<T>(move(contract_holder));

    return;
  }

  public get(holder: address): One.T acquires T {
    let contract: One.T;

    T { contract } = move_from<T>(move(holder));

    return move(contract);
  }
}

// Create the contract and store it somewhere.
//! new-transaction
//! sender: alice
import {{alice}}.One;
import {{alice}}.ContractStore;

main() {
  let contract: One.T;

  contract = One.create({{bob}}, {{chris}});
  ContractStore.store(move(contract));

  return;
}

// Checks the contract can be initialized properly
//! new-transaction
//! sender: bob
import {{alice}}.One;
import {{alice}}.ContractStore;
import 0x0.LibraCoin;
import 0x0.LibraAccount;

main() {
  let contract: One.T;

  contract = ContractStore.get({{alice}});

  One.initialize(&mut contract);
  // TODO: REMOVE THIS LINE. This should happen in initialization in the future.
  One.deposit(&mut contract, LibraAccount.withdraw_from_sender(1));

  ContractStore.store(move(contract));

  return;
}

// Checks chris can execute the one
//! new-transaction
//! sender: chris
import {{alice}}.One;
import {{alice}}.ContractStore;
import 0x0.LibraCoin;
import 0x0.LibraAccount;

main() {
  let contract: One.T;

  contract = ContractStore.get({{bob}});

  One.transition_1_0(&mut contract);

  ContractStore.store(move(contract));

  return;
}
