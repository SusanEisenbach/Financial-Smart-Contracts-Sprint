//! new-transaction
//! sender: alice
module ContractStore {
  import {{alice}}.One;
  import 0x0.Vector;

  resource T {
    contracts: Vector.T<One.T>,
  }

  // Have alice call this
  public create_store() {
    let store: Self.T;

    store = T {
      contracts: Vector.empty<One.T>(),
    };

    move_to_sender<T>(move(store));

    return;
  }

  public store(contract: One.T, holder: address) acquires T {
    let contract_holder: Self.T;
    let contracts: &mut Vector.T<One.T>;

    contracts = &mut borrow_global_mut<T>(move(holder)).contracts;

    Vector.push_back<One.T>(move(contracts), move(contract));

    return;
  }

  public get(holder: address): One.T acquires T {
    return Vector.pop_back<One.T>(&mut borrow_global_mut<T>(move(holder)).contracts);
  }
}

// Create the contract and store it somewhere.
//! new-transaction
//! sender: alice
import {{alice}}.One;
import {{alice}}.ContractStore;

main() {
  let contract: One.T;

  contract = One.create({{bob}}, {{chris}});
  ContractStore.create_store();
  ContractStore.store(move(contract), {{alice}});

  return;
}

// Checks the contract can be initialized properly
//! new-transaction
//! sender: bob
import {{alice}}.One;
import {{alice}}.ContractStore;
import 0x0.LibraCoin;
import 0x0.LibraAccount;

main() {
  let contract: One.T;

  contract = ContractStore.get({{alice}});

  One.initialize(&mut contract);
  // TODO: REMOVE THIS LINE. This should happen in initialization in the future.
  One.deposit(&mut contract, LibraAccount.withdraw_from_sender(1));

  ContractStore.store(move(contract), {{alice}});

  return;
}

// Checks chris can execute the one
//! new-transaction
//! sender: chris
import {{alice}}.One;
import {{alice}}.ContractStore;
import 0x0.LibraCoin;
import 0x0.LibraAccount;

main() {
  let contract: One.T;

  contract = ContractStore.get({{alice}});

  One.transition_1_0(&mut contract);

  ContractStore.store(move(contract), {{alice}});

  return;
}
