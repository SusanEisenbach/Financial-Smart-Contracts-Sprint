//! account: alice, 1000000
//! account: bob, 1000000
//! account: chris, 1000000

//! new-transaction
//! sender: alice
module One {
    import 0x0.LibraAccount;
    import 0x0.LibraCoin;

    resource T {
        counterparty: address,
        locked: LibraCoin.T,
    }

    public create(counterparty: address): Self.T {
        let contract: Self.T;

        contract = T {
            counterparty: move(counterparty),
            locked: LibraCoin.zero(),
        };

        return move(contract);
    }

    // Initialize the contract as the holder.
    public initialize(contract_ref: &mut Self.T) {
        LibraCoin.deposit(&mut move(contract_ref).locked, LibraAccount.withdraw_from_sender(1));

        return;
    }

    // Acquires the contract and releases all inner resources.
    public acquire(contract: Self.T) {
        let counterparty: address;
        let sender: address;
        let locked: LibraCoin.T;

        T { counterparty, locked } = move(contract);

        sender = get_txn_sender();
        assert(copy(counterparty) == move(sender), 401);
        LibraAccount.deposit(copy(counterparty), move(locked));

        return;
    }

}
//! new-transaction
//! sender: alice
module ContractManager {
    import {{alice}}.One;

    resource ContractProposal {
        contract: One.T,
    }

    resource ContractRequest {
        holder: address,
        contract: One.T,
    }

    public create_request(holder: address, contract: One.T) {
        let request: Self.ContractRequest;

        request = ContractRequest {
            holder: move(holder),
            contract: move(contract),
        };

        move_to_sender<ContractRequest>(move(request));

        return;
    }

    public create_proposal(contract: One.T) {
        let proposal: Self.ContractProposal;

        // TODO: Must be initialized when proposing, need to check it has been
        // initialized at some point before acquiring. Might need a bool somewhere.
        proposal = ContractProposal {
            contract: move(contract),
        };

        move_to_sender<ContractProposal>(move(proposal));

        return;
    }

    public sign_proposal_by(holder: address) acquires ContractProposal {
        let proposal: Self.ContractProposal;
        let contract: One.T;

        proposal = move_from<ContractProposal>(move(holder));
        ContractProposal { contract } = move(proposal);

        One.acquire(move(contract));

        return;
    }

    public approve_request_from(counterparty: address) acquires ContractRequest {
        let request_ref: &mut Self.ContractRequest;
        let holder_ref: &address;
        let contract_ref: &mut One.T;

        request_ref = borrow_global_mut<ContractRequest>(move(counterparty));
        holder_ref = &copy(request_ref).holder;

        assert(*move(holder_ref) == get_txn_sender(), 1);

        contract_ref = &mut move(request_ref).contract;
        One.initialize(move(contract_ref));

        return;
    }

    public sign_approved_request() acquires ContractRequest {
        let request: Self.ContractRequest;
        let contract: One.T;
        let holder: address;

        // TODO: Must be initialized when proposing, need to check it has been
        // initialized at some point before acquiring. Might need a bool somewhere.
        request = move_from<ContractRequest>(get_txn_sender());
        ContractRequest { holder, contract } = move(request);

        One.acquire(move(contract));

        return;
    }
}

// -----------
// TEST 1:
// Test you alice (the holder) can propose a contract
// and bob (the counterparty) can acquire it.
// -----------

//! new-transaction
//! sender: alice
import {{alice}}.One;
import {{alice}}.ContractManager;

main() {
    let contract: One.T;

    contract = One.create({{bob}});
    One.initialize(&mut contract);

    ContractManager.create_proposal(move(contract));

    return;
}

//! new-transaction
//! sender: bob
import {{alice}}.ContractManager;
import 0x0.LibraAccount;

main() {
    let initial_balance: u64;

    initial_balance = LibraAccount.balance({{bob}});
    ContractManager.sign_proposal_by({{alice}});

    assert(move(initial_balance) + 1 == LibraAccount.balance({{bob}}), 1);

    return;
}

// -----------
// TEST 2:
// Test you bob (the counterparty) can request a contract and alice (the holder)
// can provide you with a new initalized contract that bob can acquire.
// -----------

//! new-transaction
//! sender: bob
import {{alice}}.One;
import {{alice}}.ContractManager;

main() {
    let contract: One.T;

    contract = One.create({{bob}});
    ContractManager.create_request({{alice}}, move(contract));

    return;
}

//! new-transaction
//! sender: alice
import {{alice}}.One;
import {{alice}}.ContractManager;

main() {
    let contract: One.T;

    ContractManager.approve_request_from({{bob}});

    return;
}

//! new-transaction
//! sender: bob
import {{alice}}.ContractManager;
import 0x0.LibraAccount;

main() {
    let initial_balance: u64;

    initial_balance = LibraAccount.balance({{bob}});
    ContractManager.sign_approved_request();

    assert(move(initial_balance) + 1 == LibraAccount.balance({{bob}}), 1);

    return;
}
