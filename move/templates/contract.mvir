module Contract {
    {%- for dependency in self.dependencies() %}
    import {{ dependency }};
    {%- endfor %}

    resource T {
        coin_store: LibraCoin.T,
        holder: address,
        counterparty: address,
        contexts: Vector.T<Self.Context>,
        {%- for property in self.properties() %}
        {{ property.name }}: {{ property.type_name }},
        {%- endfor %}
    }

    resource Context {
        state: u64,
        flipped: bool,
        scale: u64,
    }

    // Create a contract with a holder and counterparty.
    public create(holder: address, counterparty: address): Self.T {
        let contract: Self.T;

        contract = T {
            coin_store: LibraCoin.zero(),
            holder: move(holder),
            counterparty: move(counterparty),
            contexts: Vector.empty<Self.Context>(),
            {%- for property in self.properties() %}
            {{ property.name }}: {{ property.default.as_ref().unwrap() }},
            {%- endfor %}
        };

        return move(contract);
    }

    public initialize(contract_ref: &mut Self.T) {
        Vector.push_back<Self.Context>(&mut move(contract_ref).contexts, Context {
            state: 1,
            flipped: false,
            scale: 1,
        });

        return;
    }

    public deposit(contract_ref: &mut Self.T, coin: LibraCoin.T) {
        LibraCoin.deposit(&mut move(contract_ref).coin_store, move(coin));

        return;
    }

    {% for transition in transition_methods %}
    public transition_{{ transition.origin_state() }}_{{ transition.to_state() }}(contract_ref: &mut Self.T, context_index: u64) {
        let contexts: &mut Vector.T<Self.Context>;
        let context_ref: &mut Self.Context;
        {% for definition in transition.definitions() %}
        let {{ definition.name }}: {{ definition.type_name }};
        {% endfor %}

        // Get the specified context.
        contexts = &mut copy(contract_ref).contexts;
        context_ref = Vector.borrow_mut<Self.Context>(copy(contexts), copy(context_index));

        // Check the current state to make sure we can execute this transition.
        assert(*(&mut copy(context_ref).state) == {{ transition.origin_state() }}, 1);

        // Check the conditions for this transition.
        {%- for condition in transition.conditions() %}
        {{ condition }}
        {%- endfor %}

        // Initialize the variable definitions
        {% for definition in transition.definitions() %}
        {% if !definition.default.is_none() %}
        {{ definition.name }} = {{ definition.default.as_ref().unwrap() }};
        {% endif %}
        {% endfor %}

        {%- for action in transition.actions() %}
        {{ action }}
        {%- endfor %}

        // Update the current state for the given context
        *(&mut move(context_ref).state) = {{ transition.to_state() }};

        {%- for action in transition.post_execution_actions() %}
        {{ action }}
        {%- endfor %}

        return;
    }
    {% endfor %}

    // TODO: Figure out destroy, requires destroying all contexts as well.
    // Destroy the contract resource.
    // public destroy(contract: Self.T) {}

}
