module Contract {
    {%- for dependency in self.dependencies() %}
    import {{ dependency }};
    {%- endfor %}

    resource T {
        coinstores: Vector.T<LibraCoin.T>,
        contexts: Vector.T<Self.Context>,
        {%- for property in self.properties() %}
        {{ property.name }}: {{ property.type_name }},
        {%- endfor %}
    }

    resource Context {
        state: u64,
        coinstore_index: u64,
        party: address,
        counterparty: address,
        scale: u64,
    }

    // Create a contract with a party and counterparty.
    public create() {
        let contract: Self.T;

        contract = T {
            coinstores: Vector.empty<LibraCoin.T>(),
            contexts: Vector.empty<Self.Context>(),
            {%- for property in self.properties() %}
            {{ property.name }}: {{ property.default.as_ref().unwrap() }},
            {%- endfor %}
        };

        move_to_sender<T>(move(contract));

        return;
    }

    public initialize(owner: address, party: address, counterparty: address) acquires T {
        let contract_ref: &mut Self.T;
        let coinstore_index: u64;

        contract_ref = borrow_global_mut<T>(move(owner));
        coinstore_index = Vector.length<Self.Context>(&copy(contract_ref).contexts);
        Vector.push_back<LibraCoin.T>(&mut copy(contract_ref).coinstores, LibraCoin.zero());

        Vector.push_back<Self.Context>(&mut move(contract_ref).contexts, Context {
            state: 1,
            coinstore_index: move(coinstore_index),
            party: move(party),
            counterparty: move(counterparty),
            scale: 1,
        });

        return;
    }

    public deposit(owner: address, coin: LibraCoin.T, coinstore_index: u64) acquires T {
        LibraCoin.deposit(
            Vector.borrow_mut<LibraCoin.T>(
                &mut borrow_global_mut<T>(move(owner)).coinstores,
                move(coinstore_index)
            ),
            move(coin));

        return;
    }

    {% for transition in transition_methods %}
    public transition_{{ transition.origin_state() }}_{{ transition.to_state() }}(owner: address, context_index: u64) acquires T {
        let contract_ref: &mut Self.T;
        let contexts: &mut Vector.T<Self.Context>;
        let context_ref: &mut Self.Context;
        {% for definition in transition.definitions() %}
        let {{ definition.name }}: {{ definition.type_name }};
        {% endfor %}

        contract_ref = borrow_global_mut<T>(move(owner));
        // Get the specified context.
        contexts = &mut copy(contract_ref).contexts;
        context_ref = Vector.borrow_mut<Self.Context>(copy(contexts), copy(context_index));

        // Check the current state to make sure we can execute this transition.
        assert(*(&mut copy(context_ref).state) == {{ transition.origin_state() }}, 1);

        // Check the conditions for this transition.
        {%- for condition in transition.conditions() %}
        {{ condition }}
        {%- endfor %}

        // Initialize the variable definitions
        {% for definition in transition.definitions() %}
        {% if !definition.default.is_none() %}
        {{ definition.name }} = {{ definition.default.as_ref().unwrap() }};
        {% endif %}
        {% endfor %}

        {%- for action in transition.actions() %}
        {{ action }}
        {%- endfor %}

        return;
    }
    {% endfor %}

    // TODO: Figure out destroy, requires destroying all contexts as well.
    // Destroy the contract resource.
    // public destroy(contract: Self.T) {}

}
