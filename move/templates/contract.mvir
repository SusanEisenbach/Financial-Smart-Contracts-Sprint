module Contract {
    // TODO: get imports from module.
    import 0x0.LibraCoin;
    import 0x0.LibraAccount;
    {%- for dependency in self.dependencies() %}
    import {{ dependency }};
    {%- endfor %}

    resource T {
        coin_store: LibraCoin.T,
        holder: address,
        counterparty: address,
        {%- for property in self.properties() %}
        {{ property.name }}: {{ property.type_name }},
        {%- endfor %}
    }

    resource Context {
        state: u64,
        flipped: bool,
        scale: u64,
    }

    // Create a contract with a holder and counterparty.
    public create(holder: address, counterparty: address): Self.T {
        let contract: Self.T;

        contract = T {
            state: 0,
            coin_store: LibraCoin.zero(),
            holder: move(holder),
            counterparty: move(counterparty),
            {%- for property in self.properties() %}
            {{ property.name }}: {{ property.default.as_ref().unwrap() }},
            {%- endfor %}
        };

        return move(contract);
    }

    public initialize(contract_ref: &mut Self.T) {
        let state_ref: &mut u64;

        state_ref = &mut copy(contract_ref).state;

        assert(*copy(state_ref) == 0, 1);

        // TODO: make this do what is needed to initialize the contract, for
        // example deposit funds in escrow.

        *move(state_ref) = 1;

        return;
    }

    public deposit(contract_ref: &mut Self.T, coin: LibraCoin.T) {
        LibraCoin.deposit(&mut move(contract_ref).coin_store, move(coin));

        return;
    }

    {% for transition in transition_methods %}
    public transition_{{ transition.origin_state() }}_{{ transition.to_state() }}(contract_ref: &mut Self.T) {
        let context_ref: &mut Self.Context;

        context_ref = &mut copy(contract_ref).{{ transition.context() }};

        // Check the conditions for this transition.
        {%- for condition in transition.conditions() %}
        {{ condition }}
        {%- endfor %}

        // Check the current state to make sure we can execute this transition.
        assert(*(&mut copy(context_ref).state) == {{ transition.origin_state() }}, 1);

        {%- for action in transition.actions() %}
        {{ action }}
        {%- endfor %}

        *(&mut move(context_ref).state) = {{ transition.to_state() }};

        return;
    }
    {% endfor %}

    // Destroy the contract resource.
    public destroy(contract: Self.T) {
        let state: u64;
        let coin_store: LibraCoin.T;
        let holder: address;
        let counterparty: address;
        let scale: u64;

        // TODO: allow destruction before initialization or acquiring.

        // Destroy the contract.
        T { state, coin_store, holder, counterparty, scale } = move(contract);

        // Check we are in a terminal state.
        assert(copy(state) == 0, 401);

        LibraCoin.destroy_zero(move(coin_store));

        return;
    }
}
