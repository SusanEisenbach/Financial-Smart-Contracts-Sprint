module Contract {
    {%- for dependency in self.dependencies() %}
    import {{ dependency }};
    {%- endfor %}

    resource T {
        coin_store: LibraCoin.T,
        contexts: Vector.T<Self.Context>,
    }

    resource Context {
        state: u64,
        holder: address,
        counterparty: address,
        scale: u64,
    }

    public create(): Self.T {
        let contract: Self.T;

        contract = T {
            coin_store: LibraCoin.zero(),
            contexts: Vector.empty<Self.Context>(),
        };

        return move(contract);
    }

    public initialize(contract_ref: &mut Self.T, holder: address, counterparty: address) {
        Vector.push_back<Self.Context>(&mut move(contract_ref).contexts, Context {
            state: {{ initial_state }},
            holder: move(holder),
            counterparty: move(counterparty),
            scale: 1,
        });

        return;
    }

    // TODO: create this in code generation.
    public deposit(contract_ref: &mut Self.T, coin: LibraCoin.T) {
        LibraCoin.deposit(&mut move(contract_ref).coin_store, move(coin));
        return;
    }

    {% for method in methods -%}
    {{ method }}

    {% endfor -%}

    // TODO: figure out destroy, requires destroying all contexts as well.
    // public destroy(contract: Self.T) {}
}
