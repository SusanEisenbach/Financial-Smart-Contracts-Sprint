module {{name}} {
    {%- for dependency in self.dependencies() %}
    import {{ dependency }};
    {%- endfor %}

    resource T {
        counterparty: address,
        {%- for item in self.properties() %}
        {{ item.name }}: {{ item.type_name }},
        {%- endfor %}
    }

    public create(counterparty: address): Self.T {
        let contract: Self.T;

        contract = T {
            counterparty: move(counterparty),
            {%- for item in self.properties() %}
            {{ item.name }}: {{ item.default.unwrap() }},
            {%- endfor %}
        };

        return move(contract);
    }

    // Initialize the contract as the holder.
    public initialize(contract_ref: &mut Self.T) {
        {%- for def in initialize.definitions() %}
        let {{ def.name }}: {{ def.type_name }};
        {%- endfor %}

        {%- for action in initialize.actions() %}
        {{ action }}
        {%- endfor %}

        return;
    }

    {%- if is_conditional %}

    // Acquires the contract, allowing you to claim the inner resource when the condition is true
    public acquire(contract_ref: &mut Self.T) {
        let acquired_ref: &mut bool;
        let counterparty_ref: &mut address;
        let sender: address;
        {%- for def in acquire.definitions() %}
        let {{ def.name }}: {{ def.type_name }};
        {%- endfor %}

        // We can add checks here to see if you can still acquire the contract
        // or if it is too late.
        // TODO

        counterparty_ref = &mut copy(contract_ref).counterparty;
        sender = get_txn_sender();
        assert(*move(counterparty_ref) == move(sender), 401);

        acquired_ref = &mut move(contract_ref).acquired;
        assert(*copy(acquired_ref) == false, 1);

        *move(acquired_ref) = true;

        return;
    }

    // TODO: Add templating to this when we require it -- when observables exist.
    public acquire_inner_contract(contract: Self.T): InnerContractType {
        let holder: address;
        let counterparty: address;
        let acquired: bool;
        let sender: address;
        let inner_contract: InnerContractType;

        // TODO: Do some check to make sure we are past time t1.
        assert(true, 401);

        T { holder, counterparty, acquired, inner_contract } = move(contract);

        sender = get_txn_sender();
        // Thses checks might actually belong to the wrapper rather than the contract.
        assert(move(counterparty) == move(sender), 401);
        assert(move(acquired) == true, 1);

        return move(inner_contract);
    }

    {% else %}

    // Acquires the contract and releases all inner resources.
    public acquire(contract: Self.T) {
        let counterparty: address;
        let sender: address;
        {%- for item in self.properties() %}
        let {{ item.name }}: {{ item.type_name }};
        {%- endfor %}
        {%- for def in acquire.definitions() %}
        let {{ def.name }}: {{ def.type_name }};
        {%- endfor %}

        T { counterparty{% for item in self.properties() %}, {{ item.name }}{% endfor %} } = move(contract);

        sender = get_txn_sender();
        assert(copy(counterparty) == move(sender), 401);

        {%- for action in acquire.actions() %}
        {{ action }}
        {%- endfor %}

        return;
    }

    {%- endif %}

}
