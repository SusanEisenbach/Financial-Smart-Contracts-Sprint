module Contract {
    {%- for dependency in self.dependencies() %}
    import {{ dependency }};
    {%- endfor %}

    resource T {
        coin_store: LibraCoin.T,
        holder: address,
        counterparty: address,
        {%- for property in self.properties() %}
        {{ property.name }}: {{ property.type_name }},
        {%- endfor %}
    }

    resource Context {
        state: u64,
        flipped: bool,
        scale: u64,
    }

    // Create a contract with a holder and counterparty.
    public create(holder: address, counterparty: address): Self.T {
        let contract: Self.T;

        contract = T {
            coin_store: LibraCoin.zero(),
            holder: move(holder),
            counterparty: move(counterparty),
            {%- for property in self.properties() %}
            {{ property.name }}: {{ property.default.as_ref().unwrap() }},
            {%- endfor %}
        };

        return move(contract);
    }

    public initialize(contract_ref: &mut Self.T) {
        let state_ref: &mut u64;

        state_ref = &mut (&mut copy(contract_ref).{{ initial_context }}).state;

        assert(*copy(state_ref) == 0, 1);

        // TODO: make this do what is needed to initialize the contract, for
        // example deposit funds in escrow.

        *move(state_ref) = 1;

        return;
    }

    public deposit(contract_ref: &mut Self.T, coin: LibraCoin.T) {
        LibraCoin.deposit(&mut move(contract_ref).coin_store, move(coin));

        return;
    }

    {% for transition in transition_methods %}
    public transition_{{ transition.origin_state() }}_{{ transition.to_state() }}(contract_ref: &mut Self.T, context_id: u64) {
        let context_ref: &mut Self.Context;
        let context_match: bool;
        {% for definition in transition.definitions() %}
        let {{ definition.name }}: {{ definition.type_name }};
        {% endfor %}

        // Get the specified context.
        // TODO: Once arrays are implemented replace all of this with an array of contexts.
        context_match = false;
        context_ref = &mut copy(contract_ref).{{ initial_context }};
        {% for (context_id, context) in self.contexts() %}
        {% if !transition.excluded_contexts().contains(context_id) %}
        if (copy(context_id) == {{ context_id }}) {
            context_ref = &mut copy(contract_ref).{{ context.name }};
            context_match = true;
        }
        {% endif %}
        {% endfor %}
        assert((copy(context_match)) || (copy(context_id) == 0), 404);

        // Check the current state to make sure we can execute this transition.
        assert(*(&mut copy(context_ref).state) == {{ transition.origin_state() }}, 1);

        // Check the conditions for this transition.
        {%- for condition in transition.conditions() %}
        {{ condition }}
        {%- endfor %}

        // Initialize the variable definitions
        {% for definition in transition.definitions() %}
        {% if !definition.default.is_none() %}
        {{ definition.name }} = {{ definition.default.as_ref().unwrap() }};
        {% endif %}
        {% endfor %}

        {%- for action in transition.actions() %}
        {{ action }}
        {%- endfor %}

        // Update the current state for the given context
        *(&mut move(context_ref).state) = {{ transition.to_state() }};

        return;
    }
    {% endfor %}

    // TODO: Figure out destroy, requires destroying all contexts as well.
    // Destroy the contract resource.
    // public destroy(contract: Self.T) {}

}
