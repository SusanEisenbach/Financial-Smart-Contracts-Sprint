//! account: sprint
//! account: alice
//! account: bob
//! account: chris

//! new-transaction
//! sender: sprint
module Transfer {
    import 0x0.LibraAccount;
    import 0x0.LibraCoin;

    resource T {
        counterparty: address,
        coin: LibraCoin.T,
    }

    public create(counterparty: address, amount: u64): Self.T {
        let contract: Self.T;
        let coin: LibraCoin.T;

        coin = LibraAccount.withdraw_from_sender(move(amount));

        contract = T {
            counterparty: move(counterparty),
            coin: move(coin),
        };

        return move(contract);
    }

    public acquire(contract: Self.T) {
        let counterparty: address;
        let coin: LibraCoin.T;
        let sender: address;

        T { counterparty, coin } = move(contract);

        sender = get_txn_sender();
        assert(copy(counterparty) == move(sender), 401);

        LibraAccount.deposit(move(counterparty), move(coin));

        return;
    }

}

//! new-transaction
//! sender: sprint
module Zcb {
    // scaleK 100 (get (truncate t1 (one Libra)))
    // \receive $100 at time t1
    
    import {{sprint}}.Transfer;

    resource T {
        holder: address,
        counterparty: address,
        acquired: bool,
        inner_contract: Transfer.T,
    }

    // Create a Zcb so that the contract acquire will receive `amount` in the future.
    public create(counterparty: address, amount: u64): Self.T {        
        let contract: Self.T;
        let sender: address;
        let inner_contract: Transfer.T;

        sender = get_txn_sender();
        inner_contract = Transfer.create(copy(counterparty), move(amount));

        contract = T {
            holder: move(sender),
            counterparty: move(counterparty),
            acquired: false,
            inner_contract: move(inner_contract),
        };

        return move(contract);
    }

    public acquire(contract_ref: &mut Self.T) {
        let acquired_ref: &mut bool;
        let counterparty_ref: &mut address;
        let sender: address;

        // We can add checks here to see if you can still acquire the contract
        // or if it is too late.

        counterparty_ref = &mut copy(contract_ref).counterparty;
        sender = get_txn_sender();
        assert(*move(counterparty_ref) == move(sender), 401);

        acquired_ref = &mut move(contract_ref).acquired;
        assert(*copy(acquired_ref) == false, 1);

        *move(acquired_ref) = true;

        return;
    }

    public acquire_inner_contract(contract: Self.T): Transfer.T {
        let holder: address;
        let counterparty: address;
        let acquired: bool;
        let sender: address;
        let inner_contract: Transfer.T;

        // TODO: Do some check to make sure we are past time t1.
        assert(true, 401);

        T { holder, counterparty, acquired, inner_contract } = move(contract);

        sender = get_txn_sender();
        // Thses checks might actually belong to the wrapper rather than the contract.
        assert(move(counterparty) == move(sender), 401);
        assert(move(acquired) == true, 2);

        return move(inner_contract);
    }

}

//! new-transaction
//! sender: alice
module ContractWrapper1 {
    import {{sprint}}.Zcb;
    import {{sprint}}.Transfer;

    resource T {
        contract: Zcb.T,
    }

    public create(counterparty: address, amount: u64) {
        let contract_wrapper: Self.T;
        let contract: Zcb.T;

        contract = Zcb.create(move(counterparty), move(amount));

        contract_wrapper = T {
            contract: move(contract),
        };

        move_to_sender<T>(move(contract_wrapper));

        return;
    }

    // TODO: Instead of making these wrappers, just have something that
    // returns a reference to the contract so that you can call the methods
    // of the contract directly from the scripts.
    // Consider the security implications of this... might actually not want to
    // do this...
    public acquire(holder: address) acquires T {
        let contract_wrapper: &mut Self.T;
        let contract_ref: &mut Zcb.T;

        contract_wrapper = borrow_global_mut<T>(move(holder));
        contract_ref = &mut copy(contract_wrapper).contract;

        Zcb.acquire(move(contract_ref));

        return;
    }

    // TODO: Same as above.
    // Should be called unwrap inner contract or something like this.
    public acquire_inner_contract(holder: address): Transfer.T acquires T {
        let contract_wrapper: Self.T;
        let contract: Zcb.T;
        let inner_contract: Transfer.T;

        contract_wrapper = move_from<T>(move(holder));
        T { contract } = move(contract_wrapper);

        inner_contract = Zcb.acquire_inner_contract(move(contract));

        return move(inner_contract);
    }
}

// //! new-transaction
// //! sender: alice
// module ContractWrapper2 {
//     TODO: Copy paste the above contract. The wrappers allows you to have
//           multiples of the same contract without needing to redeploy everything.
// }

//! new-transaction
//! sender: alice
import {{alice}}.ContractWrapper1;
// import {{alice}}.ContractWrapper2;

main() {
    ContractWrapper1.create({{bob}}, 10);
    // ContractWrapper2.create({{chris}});

    return;
}

//! new-transaction
//! sender: bob
import {{alice}}.ContractWrapper1;
import {{sprint}}.Transfer;
import 0x0.LibraAccount;

main() {
    let c: Transfer.T;
    let initial_balance: u64;
    let final_balance: u64;

    initial_balance = LibraAccount.balance({{alice}});

    ContractWrapper1.acquire({{alice}});
    c = ContractWrapper1.acquire_inner_contract({{alice}});

    Transfer.acquire(move(c));

    final_balance = LibraAccount.balance({{alice}});

    // Figure out why this is failing.
    assert((move(initial_balance) + 10) == move(final_balance), 1);

    return;
}

// //! new-transaction
// //! sender: bob
// import {{alice}}.ContractWrapper1;

// main() {
//     ContractWrapper1.acquire({{alice}});

//     return;
// }
// // should fail already acquired error.
// // check: ABORTED
// // check: 1

// I'm already certain their test suite is broken it can't do 
// this aborting checking if there already is one in the code... 
// Litterally just ignore this should fail...
// If you want to uncomment this out, comment out the other ABORTED check.
// //! new-transaction
// //! sender: chris
// import {{alice}}.ContractWrapper1;

// main() {
//     ContractWrapper1.acquire({{alice}});

//     return;
// }
// // should fail with unauthorized error
// // check: ABORTED
// // check: 401