module one {
  import 0x0.LibraCoin;

  resource T {
    coin: LibraCoin.T,
    counter_party: address,
  }

  // Creates the contract (as a resource) and moves it to the transaction sender's account.
  public create(coin: LibraCoin.T, recipient: address) {
    let t: Self.T;

    t = T {
      coin: move(coin),
      counter_party: move(recipient),
    }

    // Publish the contract under the transaction sender's account
    move_to_sender<T>(move(t));
    return;
  }

  // "Signs" the contract held by the holder_address, making the
  // transaction sender the counterparty to the contract
  public sign(holder_address: address): Self.T acquires T {
    let contract: Self.T;
    let sender: address;

    // Move the contract resource (T) from the holder_address to the variable contract.
    // If there is no resource of type T published under the address, this transaction will fail.
    contract = move_from<T>(move(holder_address));

    sender = get_txn_sender();

    // Ensure the transaction sender is the intended counter_party.
    // If this assertion fails, the transcation will fail (none of it's effects will be commited).
    // Will emmit a 401 error code with the transaction output if this assertion fails.
    assert(*(&move(&contract).recipient) == move(sender), 401);

    return move(t);
  }

  // Destroys/consumes the contract releasing its resources.
  public unwrap(contract: Self.T) {
    let coin: LibraCoin.T;
    let counter_party: address;

    // "Unpacks" the contract by destroying the outer resource returing its contents.
    T { coin, counter_party } = move(contract);

    return move(coin);
  }
}
